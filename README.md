# Stack
Библиотека для стандартной структуры данных - стека.

1. [Использование библиотеки.](#использование-библиотеки)
2. [Описание библиотеки.](#описание-библиотеки)

### Использование библиотеки

1. Подключить билиотеку к проекту:

* Первый способ, компиляция вручную. Скачать исходный код билиотеки.
Папка `Logs` содержит функции для создания логов.
Папка `StackLibrary` содержит функции для работы со стеком.
Подключить к проекту-клиенту заголовочный файл `Stack.h`. Скомпилировать файлы проекта и библиотеки.

* Второй способ, подключение статической библиотеки. Скачать статическую библиотеку `stack.lib` и заголовочный файл `Stack.h`.
Подключить к проекту-клиенту заголовочный файл `Stack.h`. Добавить к проекту статическую библиотеку. Скомпилировать проект, не забыв включить библиотеку.

2. Включить лог стека:
```C++
FILE* file = fopen("StackLibrary.html", "w");
stackLogFile = file;
StackLogConstructor(stackLogFile);
```
Не забыдь вызвать `fclose(stackLogFile);` при завершении работы программы.
Либо закомментировать константы, чтобы убрать логи стека.
```C++
#define StackLogs
#define StackLogErrors
```
3. Создать структуру стека:
```C++
Stack stk = {};//Инициализация {} обязательна
```
4. Вызвать конструктор:
```C++
StackConstructor(&stk, elemSize, 0);
```
5. При завершении работы со стеком вызвать деструктор:
```C++
StackDestructor(&stk);
```

### Описание библиотеки

1. `Stack.h` содержит основные функции работы со стеком.
```C++
/**
 * @brief Структура данных стек.
*/
struct Stack
{
    int64_t canaryLeft;    /// Левая канарейка.

    size_t  elementSize;   /// Размер одного элемента.
    size_t  stackSize;     /// Текущий размер стека. Количество элементов, находящихся в стеке в данный момент.
    size_t  stackCapacity; /// Вместимость стека, максимальное число элементов, которые может хранить стек.

    void*   data;          /// Массив данных.

    int64_t dataCRC;       /// Контрольная сумма массива данных.
    int64_t stackCRC;      /// Контрольная сумма структуры стек.

    int64_t canaryRight;   /// Правая канарейка.
};

/**
 * @brief             Конструктор стека.
 * @param stack       Указатель на стек.
 * @param elementSize Размер одного элемента в массиве data.
 * @param Capacity    Начальная вместимость стека. По умолчанию 0. Если значение больше 0, то под данные будет выделена память.
 * @return            Код ошибки, 0 - в случае успешного завершения.
*/
int   StackConstructor(Stack *stack, size_t elementSize, size_t Capacity = 0);

/**
 * @brief       Деструктор стека.
 * @param stack Указатель на стек.
 * @return      Код ошибки, 0 - в случае успешного завершения.
*/
int   StackDestructor(Stack *stack);

/**
 * @brief       Добавляет элемент в конец стека.
 * @param stack Указатель на стек.
 * @param value Указатель на значение, которое нужно добавить в стек.
 * @return      Код ошибки, 0 - в случае успешного завершения.
*/
int   StackPush(Stack *stack, void *value);

/**
 * @brief       Удаляет элемент из конца стека и возвращает его.
 * @param stack Указатель на стек.
 * @param error Если не nullptr, то этой переменной будут присвоены коды ошибок, которые произошли во время работы функции.
 * @return      Значение удалённого из стека элемента, nullptr - в случае ошибки.
*/
void* StackPop(Stack *stack, int *error = nullptr);

/**
 * @brief       Проверяет стек на наличии ошибок.
 * @param stack Указатель на стек.
 * @return      Возвращает коды ошибок текущего состояния стека.
*/
int   ValidateStack(Stack *stack);

/**
 * @brief       Выводит детальную информацию о текущем состоянии стека.
 * @param stack Указатель на стек.
 * @param file  Указатель на поток вывода
*/
#define StackDump(stack, file)

/**
 * @brief      Констркуктор файла логов стека.
 * @param file Указатель на поток вывода.
*/
void StackLogConstructor(FILE* file);

```